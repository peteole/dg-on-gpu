var documenterSearchIndex = {"docs":
[{"location":"#TerraDG.jl-on-the-GPU","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"(Image: Euler equations solution)","category":"page"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"This is a solution of the Euler equations using the TerraDG.jl package on the GPU. The video shows the density of the fluid at different time steps. The simulation is run on a 500x500 grid with a fourth-order solver.","category":"page"},{"location":"#Running-the-code","page":"TerraDG.jl on the GPU","title":"Running the code","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"Clone the repo\nStart Julia in the root directory of the project with julia --project=.. Optionally, you can set the number of threads with export JULIA_NUM_THREADS=8.\nRun ] instantiate to install the dependencies.\nRun include(\"src/main.jl\") to run the code. You can change the parameters in the main.jl file. Note that the increased complexity and number of dependencies of the project increased precompilation time, sometimes taking up to around 3 minutes.","category":"page"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"In addition to the parameters from the worksheets, you can specify the following parameters in the input file:","category":"page"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"solver.slope_limiting: true: Activate minmod slope limiting.\nsimulation.device: cuda:3: Select the device to run the simulation on. The default is cpu. Allowed values are cpu,cuda, cuda:X, where X is the device number, amdgpu, amdgpu:X, where X is the device number.\nsimulation.float_type: Float32: Select the floating point precision. Allowed values are Float32 and Float64.\noutput.save_images: true: Save plots of each dof in the plots folder.\noutput.log_level: warn: Set the log level. Allowed values are debug, info, warn, error.","category":"page"},{"location":"#Running-the-code-with-Docker","page":"TerraDG.jl on the GPU","title":"Running the code with Docker","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"Build the Docker image with docker build -t terradg ..\nRun the Docker container with docker run -it terradg. This will start an interactive Julia session in the TerraDG project.\nRun your experiment using using TerraDG; TerraDG.main(\"src/input/advection.yaml\").","category":"page"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"If you also wish to play with the inputs and inspect the plots, you can mount thesrc/input, output and plots directories to your host machine. First create the folders if they do not exist: mkdir plots;mkdir output. For example, run docker run -it -v $(pwd)/src/input:/app/src/input -v $(pwd)/output:/app/output -v $(pwd)/plots:/app/plots terradg. Note that GPU acceleration is not available in the Docker container.","category":"page"},{"location":"#Folder-structure","page":"TerraDG.jl on the GPU","title":"Folder structure","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"src: Contains the source code of the project.\nresults: Contains documentation for all worksheets\nbenchmark: Contains benchmarking scripts and results\noutput: Contains the output of the simulation in vtk format. Can be opened with Paraview.\nplots: Contains plots of the simulation. Can be disabled in the input file.\ntest: Contains the tests for the project.\nworksheets.ipynb: Contains the output of all worksheets in a Jupyter notebook. Running this notebook runs all the worksheet configs. In the cuda_video_output branch, this file contains the output as a video. However, we experienced compatibility issues.","category":"page"},{"location":"#Branches-and-tags","page":"TerraDG.jl on the GPU","title":"Branches and tags","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"branch main: Contains the project implementation with all optimizations.\ntags worksheet-X (X=1,2,3,4): Contains the implementation of the respective worksheet.\nbranch cuda_video_output: Contains the implementation of the video output for the Euler equations on the GPU in the worksheets.ipynb file.\nbranch cuda_derivative_factorization: Contains the project but without the surface integral optimization. More flexible (we do not make assumptions about the order of the cells here) and readable code but around 30% slower.","category":"page"},{"location":"#Testing","page":"TerraDG.jl on the GPU","title":"Testing","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"Run ] test to run the tests.","category":"page"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"","category":"page"},{"location":"#Main","page":"TerraDG.jl on the GPU","title":"Main","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.evaluate_rhs\nTerraDG.main","category":"page"},{"location":"#TerraDG.evaluate_rhs","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_rhs","text":"evaluate_rhs(eq, scenario, filter, globals, du, dofs, grid)\n\nEvalutes the right-hand-side of the equation eq for  scenario scenario, with filter filter,  collection of global matrices globals, update du, degrees of freedom dofs and grid grid.\n\nUpdates du in place.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.main","page":"TerraDG.jl on the GPU","title":"TerraDG.main","text":"main(configfile::String)\n\nRuns a DG-simulation with configuration from configfile.\n\n\n\n\n\n","category":"function"},{"location":"#I/O","page":"TerraDG.jl on the GPU","title":"I/O","text":"","category":"section"},{"location":"#Configuration","page":"TerraDG.jl on the GPU","title":"Configuration","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.Configuration\nTerraDG.get_device_array_type","category":"page"},{"location":"#TerraDG.Configuration","page":"TerraDG.jl on the GPU","title":"TerraDG.Configuration","text":"Configuration(configfile::String)\n\nParses configuration file configfile.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.get_device_array_type","page":"TerraDG.jl on the GPU","title":"TerraDG.get_device_array_type","text":"Gets the array type for the device specified in the configuration. Also sets the default device and dynamically loads the corresponding accelerator module.\n\n\n\n\n\n","category":"function"},{"location":"#VTK/Paraview-output","page":"TerraDG.jl on the GPU","title":"VTK/Paraview output","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.VTKPlotter\nTerraDG.plot\nTerraDG.save\nTerraDG.evaluate_dof_points","category":"page"},{"location":"#TerraDG.VTKPlotter","page":"TerraDG.jl on the GPU","title":"TerraDG.VTKPlotter","text":"VTKPlotter(eq::Equation, scenario::Scenario, grid::Grid,\n           filename::String)\n\nInitialize a VTKPlotter for equation eq and scenario scenario, defined on grid_gpu. The gpu grid is copied to cpu for plotting. Output name is filename.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.plot","page":"TerraDG.jl on the GPU","title":"TerraDG.plot","text":"plot(plotter::VTKPlotter)\n\nWrite output with plotter for timestep.\n\nThis function is asynchronous and returns immediately after copying the grid.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.save","page":"TerraDG.jl on the GPU","title":"TerraDG.save","text":"save(plotter::VTKPlotter)\n\nSave final output file for plotter.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_dof_points","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_dof_points","text":"evaluate_dof_points(grid::Grid, points, dofidx)\n\nEvaluate the DOF points for dofidx on grid at points, potentially on GPU.\n\nReturns the evaluated data of size (length(grid.cells)*num_points, 1).\n\n\n\n\n\n","category":"function"},{"location":"#Error-Writer","page":"TerraDG.jl on the GPU","title":"Error Writer","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.evaluate_error","category":"page"},{"location":"#TerraDG.evaluate_error","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_error","text":"evaluate_error(eq, scenario, grid, t)\n\nEvaluates the error of the solution for the equation eq and scenario scenario on the grid grid at time t. Writes the error to the console. Evaluates the error in the L1, L2 and L∞ norms.\n\n\n\n\n\n","category":"function"},{"location":"#Equations","page":"TerraDG.jl on the GPU","title":"Equations","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.Equation\nTerraDG.make_equation\nTerraDG.Scenario\nTerraDG.make_scenario\nTerraDG.interpolate_initial_dofs\nTerraDG.get_nvars\nTerraDG.get_nparams\nTerraDG.get_variable_name\nTerraDG.is_periodic_boundary\nTerraDG.evaluate_boundary\nTerraDG.get_initial_values\nTerraDG.is_analytical_solution\nTerraDG.evaluate_flux\nTerraDG.max_eigenval\nTerraDG.@declare_dofs","category":"page"},{"location":"#TerraDG.Equation","page":"TerraDG.jl on the GPU","title":"TerraDG.Equation","text":"This abstract type needs to be implemented by all equations.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.make_equation","page":"TerraDG.jl on the GPU","title":"TerraDG.make_equation","text":"make_equation(config::Configuration)\n\nReturns equation object for configuration config.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.Scenario","page":"TerraDG.jl on the GPU","title":"TerraDG.Scenario","text":"This abstract type needs to be implementred by all scenarios\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.make_scenario","page":"TerraDG.jl on the GPU","title":"TerraDG.make_scenario","text":"make_scenario(config::Configuration)\n\nReturns scenario object for configuration config.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.interpolate_initial_dofs","page":"TerraDG.jl on the GPU","title":"TerraDG.interpolate_initial_dofs","text":"This function initializes the discrete solution at t = 0 for an equation eq and a scenario scenario. It evaluates get_initial_values for eq and scenario at the global coordinates of our nodes. It then interpolates this on the basis.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_nvars","page":"TerraDG.jl on the GPU","title":"TerraDG.get_nvars","text":"This function returns the number of variables for equation eq::Equation\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_nparams","page":"TerraDG.jl on the GPU","title":"TerraDG.get_nparams","text":"This function returns the number of material parameters for equation eq::Equation.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_variable_name","page":"TerraDG.jl on the GPU","title":"TerraDG.get_variable_name","text":"get_variable_name(eq::Equation, variable_index)\n\nReturn the name of the variable with index variable_index for equation eq::Equation.\n\nImplementation\n\nCustom equations need to define get_variable_names(eq) for this to work.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.is_periodic_boundary","page":"TerraDG.jl on the GPU","title":"TerraDG.is_periodic_boundary","text":"is_periodic_boundary(equation::Equation, scenario::Scenario)\n\nReturns true if all boundary conditions should be periodic for equation eq::Equation and scenario scenario::Scenario.\n\n\n\n\n\nisperiodicboundary(eq::Acoustic, scenario::GaussianWave) The GaussianWave scenario does not require periodic boundary conditions.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_boundary","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_boundary","text":"evaluate_boundary(eq::Equation, scenario::Equation, face, normalidx, dofsface, dofsfaceneigh)\n\nEvaluate the boundary condition, defined for equation eq and scenario, on face face with normalidx. Store dofs of ghost cell in dofsfaceneigh. You can use inner (face)-dofs dofsface to construct to boundary.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_initial_values","page":"TerraDG.jl on the GPU","title":"TerraDG.get_initial_values","text":"get_initial_values(eq::Equation, scenario::Scenario, global_position; t=0.0)\n\nReturn a vector of initial values for equation eq and scenario scenario at  global_positon and at time t. Values other than t = 0 only have to be supported if is_analytical_solution returns true.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.is_analytical_solution","page":"TerraDG.jl on the GPU","title":"TerraDG.is_analytical_solution","text":"is_analytical_solution(equation::Equation, scenario::Scenario)\n\nReturns true if the initial condition is also an analytical solution  for equation equation and scenario scenario.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_flux","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_flux","text":"evaluate_flux(eq::Equation, celldofs, cellflux)\n\nEvaluate the flux for equation eq and dofs celldofs, Stores them in cellflux.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.max_eigenval","page":"TerraDG.jl on the GPU","title":"TerraDG.max_eigenval","text":"max_eigenval(eq::Equation, celldata, normalidx)\n\nReturn the maximum eigenvalue in direction of normalidx for celldata.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.@declare_dofs","page":"TerraDG.jl on the GPU","title":"TerraDG.@declare_dofs","text":"declare_dofs(eq, dof_names, num_params=0)\n\nGenerate boilerplate code for equation type eq which has degrees of freedom named dof_names (should be iterable of symbols) and num_params parameters. Generates\n\nget_variable_names(eq)\nget_ndofs(eq)\nget_nvars(eq)\nget_nparams(eq)\n\nAlso generates a struct called [typename]Shortcuts.\n\nExample\n\nstruct Advection <: Equation end\n@declare_dofs Advection [:ρ_1, :ρ_2, :ρ_3]\n\nGenerates:\n\nget_variable_names(eq::Advection) = [:ρ_1, :ρ_2, :ρ_3]\nget_ndofs(eq::Advection) = 3\nget_nvars(eq::Advection) = 3\nget_nparams(eq::Advection) = 0\n\nYou can use the struct in this way:\n\ns = AdvectionShortcuts()\n@assert s.ρ_1 == 1\n@assert s.ρ_2 == 2\n@assert s.ρ_3 == 3\n\n\n\n\n\n","category":"macro"},{"location":"#Grid","page":"TerraDG.jl on the GPU","title":"Grid","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.FaceType\nTerraDG.Cell\nTerraDG.Grid\nTerraDG.Face\nTerraDG.get_neighbor\nTerraDG.make_mesh\nTerraDG.make_grid\nTerraDG.globalposition\nTerraDG.volume\nTerraDG.area\nTerraDG.inverse_jacobian\nTerraDG.cpu","category":"page"},{"location":"#TerraDG.FaceType","page":"TerraDG.jl on the GPU","title":"TerraDG.FaceType","text":"@enum FaceType regular=1 boundary=2\n\nRegular faces are faces that have another cell as neighbor. Boundary faces are faces on the boundary, i.e., where we need to construct a solution at each timestep.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.Cell","page":"TerraDG.jl on the GPU","title":"TerraDG.Cell","text":"struct Cell\n\nCell stores all information about grid cells, such as their center center, their size size. It also contains information about its neighbors. In case it is neighbored by a boundary cell, facetypes  indicates this and the neighbor is undefined. Finally, it stores the dataidx which denotes at which position the data for the cell is stored in the relevant data arrays.\n\nThe Cell is parameterized by the floating point type F, the number of dimensions ndims and the number of neighbors num_neighbors, making it fixed size.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.Grid","page":"TerraDG.jl on the GPU","title":"TerraDG.Grid","text":"mutable struct Grid\n\nGrid stores information about the grid and also information about the whole simulation. It contains the basis for the grid, the cells of the grid, the size of the grid, the degrees of freedom dofs and the fluxes flux. It also contains the maxeigenval which is the maximum eigenvalue of the grid, the current time of the simulation, the eigenvals of the grid and the neighbour_face_flux_buffer which is used for the surface integral. Finally, it stores the cellsize of the cells.\n\nIt is parameterized by the floating point type F, the type of the cells T1, the type of the degrees of freedom T2, the number of dimensions ndims, the number of degrees of freedom ndofs, the order of the basis order and the type of the eigenvalues T3. T1, T2 and T3 are arrays potentially stored on the GPU.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.Face","page":"TerraDG.jl on the GPU","title":"TerraDG.Face","text":"@enum Face left=1 top=2 right=3 bottom=4\n\nFace describes the ordering of our faces. The order is irrelevant as long as the same order is used everywhere. Using the wrong order leads to very hard bugs!\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.get_neighbor","page":"TerraDG.jl on the GPU","title":"TerraDG.get_neighbor","text":"get_neighbor(eq, scenario, index, maxindex, offset)\n\nReturns the index of the neighboring cell. Here, index is the 2d-index of the current cell, maxindex is the maximum index, and offset is the difference in index of the neighbor. As minimum index (0,0) is assumed. Returns both the index of the neighbor and the type of the face. It handles both periodic boundary cells (returns correct neighbor and regular face type) and proper boundaries (returns periodic neighbor and boundary face type).\n\nImplementation\n\nThe type of boundaries depends on the equation and the scenario. Users can overwrite the function isperiodicboundary.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.make_mesh","page":"TerraDG.jl on the GPU","title":"TerraDG.make_mesh","text":"make_mesh(eq, scenario, gridsize_1d, cellsize, offset)\n\nReturns all cells of a mesh with number of cel(per dimension) given by  gridsize_1d, size of each cell by cellsize and offset of grid.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.make_grid","page":"TerraDG.jl on the GPU","title":"TerraDG.make_grid","text":"make_grid(eq::Equation, scenario::Scenario, gridsize_1d, size, order, ::Type{T}=Array,::Type{F}=Float64)\n\nReturns a grid for equation eq, scenario scenario, with cells of size size     and number of cells per dimension equals to gridsize_1d. The type of array and the floating point precision can be specified.\n\n\n\n\n\nmake_grid(config::Configuration, eq::Equation, scenario::Scenario)\n\nReturns a grid for configuration config, equation eq and scenario scenario\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.globalposition","page":"TerraDG.jl on the GPU","title":"TerraDG.globalposition","text":"globalposition(cell:Cell, coordinate_reference)\n\nReturns the global positon of reference coordinates coordinate_reference for a cell with center cellcenter and size cellsize.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.volume","page":"TerraDG.jl on the GPU","title":"TerraDG.volume","text":"volume(cell::Cell)\n\nReturns the volume of a quad cell. In 2D, it returns the area.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.area","page":"TerraDG.jl on the GPU","title":"TerraDG.area","text":"area(cell::Cell)\n\nReturns the area of a quad cell. In 1D, it returns the side-length.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.inverse_jacobian","page":"TerraDG.jl on the GPU","title":"TerraDG.inverse_jacobian","text":"inverse_jacobian(cellsize::NTuple{ndims,F})\n\nReturns the inverse jacobian of a cell with size cellsize.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.cpu","page":"TerraDG.jl on the GPU","title":"TerraDG.cpu","text":"Move all the data of the grid to the CPU, returns a new grid.\n\n\n\n\n\n","category":"function"},{"location":"#Basis","page":"TerraDG.jl on the GPU","title":"Basis","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.lagrange_1d\nTerraDG.lagrange_diff\nTerraDG.get_quadpoints\nTerraDG.Basis\nBase.length(::TerraDG.Basis)\nBase.size(::TerraDG.Basis)\nBase.size(::TerraDG.Basis,::Integer)\nBase.size\nTerraDG.evaluate_basis\nTerraDG.project_to_reference_basis\nTerraDG.massmatrix\nTerraDG.derivativematrix\nTerraDG.get_face_quadpoints\nTerraDG.face_projection_matrix\nTerraDG.evaluate_m_to_n_vandermonde_basis","category":"page"},{"location":"#TerraDG.lagrange_1d","page":"TerraDG.jl on the GPU","title":"TerraDG.lagrange_1d","text":"lagrange_1d(points, i, x)\n\nEvaluate the Lagrange interpolation polynomial defined over nodal points with index i at point x.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.lagrange_diff","page":"TerraDG.jl on the GPU","title":"TerraDG.lagrange_diff","text":"lagrange_diff(points, i, x)\n\nEvaluate the derivative of the Lagrange interpolation polynomial defined over nodal points  with index i at point x.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_quadpoints","page":"TerraDG.jl on the GPU","title":"TerraDG.get_quadpoints","text":"get_quadpoints(n)\n\nCompute quadrature points and weights for Gaussian quadrature of order n. The points (and thus the corresponding weights) are normalized to the range 00 10.\n\nReturn a tuple of points, weights.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.Basis","page":"TerraDG.jl on the GPU","title":"TerraDG.Basis","text":"Basis\n\nA standard 1-dimensional basis of order::Integer with quadpoints::Array{Float64,1} and  corresponding quadweights::Array{Float64,1} Is the basis (pun intended) for tensor-product bases.\n\nBasis(order::Integer, dimensions)\n\nInitialize a basis of order::Integer and dimensions dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#Base.length-Tuple{TerraDG.Basis}","page":"TerraDG.jl on the GPU","title":"Base.length","text":"Base.length(basis::Basis)\n\nReturn number of points for basis in n-dimensions.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{TerraDG.Basis}","page":"TerraDG.jl on the GPU","title":"Base.size","text":"Base.size(basis::Basis)\n\nReturn number of points for basis for each dimensions as tuple.\n\n\n\n\n\nBase.size(basis::Basis, dim)\n\nReturn number of points for basis for dimensions dim.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size-Tuple{TerraDG.Basis, Integer}","page":"TerraDG.jl on the GPU","title":"Base.size","text":"Base.size(basis::Basis, dim)\n\nReturn number of points for basis for dimensions dim.\n\n\n\n\n\n","category":"method"},{"location":"#Base.size","page":"TerraDG.jl on the GPU","title":"Base.size","text":"Base.size(basis::Basis)\n\nReturn number of points for basis for each dimensions as tuple.\n\n\n\n\n\nBase.size(basis::Basis, dim)\n\nReturn number of points for basis for dimensions dim.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_basis","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_basis","text":"evaluate_basis(basis::Basis, coeffs, x)\n\nEvaluate the basis with coefficients coeffs at point x.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.project_to_reference_basis","page":"TerraDG.jl on the GPU","title":"TerraDG.project_to_reference_basis","text":"project_to_reference_basis(fun, basis::Basis, ndofs)\n\nProject the result of the function fun to coefficients of the basis built of a tensor-product of basis. The function fun(x,y)  takes in the x y-coordinates and returns a vector with size ndofs. The corresponding coefficients are returned.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.massmatrix","page":"TerraDG.jl on the GPU","title":"TerraDG.massmatrix","text":"massmatrix(basis, dimensions)\n\nReturn the mass-matrix for a dimensions-dimensional tensor-product basis built up from the 1d-basis basis.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.derivativematrix","page":"TerraDG.jl on the GPU","title":"TerraDG.derivativematrix","text":"derivativematrix(basis)\n\nReturns the 2-dimensional derivative matrix for basis. Multiplying this with flux-coefficients of shape (dimensions * basissize_2d, ndofs) returns the coefficients of the corresponding derivative.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.get_face_quadpoints","page":"TerraDG.jl on the GPU","title":"TerraDG.get_face_quadpoints","text":"get_face_quadpoints(basis::Basis, face)\n\nReturn the quadrature points at the face face for basis basis.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.face_projection_matrix","page":"TerraDG.jl on the GPU","title":"TerraDG.face_projection_matrix","text":"face_projection_matrix(basis, face)\n\nReturn the face projection matrix for basis and face. Multiplying it with coefficient vector for the right basis returns the coefficients of the solution evaluated at the  quadrature nodes of the face.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_m_to_n_vandermonde_basis","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_m_to_n_vandermonde_basis","text":"evaluate_m_to_n_vandermonde_basis(basis)\n\nReturn the Vandermonde matrix that converts between the 2D-modal  (normalized) Legendre-basis and the 2D-nodal tensor-product basis built with basis.\n\n\n\n\n\n","category":"function"},{"location":"#Kernels","page":"TerraDG.jl on the GPU","title":"Kernels","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"Many kernels take both global matrices and buffers. Try to use them to avoid costly re-computations or memory allocations.","category":"page"},{"location":"#Global-Matrices","page":"TerraDG.jl on the GPU","title":"Global Matrices","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.GlobalMatrices","category":"page"},{"location":"#TerraDG.GlobalMatrices","page":"TerraDG.jl on the GPU","title":"TerraDG.GlobalMatrices","text":"struct GlobalMatrices\n\nStores global matrices and some other things. Everything that is very expensive to compute which stays constant throughout the simulation should be stored here.\n\nGlobalMatrices(basis::Basis, filter::Filter, dimensions)\n\nInitialize GlobalMatrices for basis, filter and dimensions.\n\n\n\n\n\n","category":"type"},{"location":"#Time","page":"TerraDG.jl on the GPU","title":"Time","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.TimeIntegrator\nTerraDG.make_timeintegrator\nTerraDG.step\nTerraDG.ExplicitEuler\nTerraDG.SSPRK2\nTerraDG.SSPRK3","category":"page"},{"location":"#TerraDG.TimeIntegrator","page":"TerraDG.jl on the GPU","title":"TerraDG.TimeIntegrator","text":"abstract type TimeIntegrator\n\nAbstract type for ODE-Integrators. They should store the update as internal state to  avoid costly reallocations.\n\nImplementation\n\nFor new integrators, the method step needs to be  overwritten. This method should modify the dofs stored in the grid in-place.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.make_timeintegrator","page":"TerraDG.jl on the GPU","title":"TerraDG.make_timeintegrator","text":"make_timeintegrator(config::Configuration, grid::Grid)\n\nReturns time integrator from config for grid.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.step","page":"TerraDG.jl on the GPU","title":"TerraDG.step","text":"step(f, integrator::ExplicitEuler, grid, dt)\n\nPerforms an update with the explicit euler method on grid and timestepsize dt.\n\n\n\n\n\nstep(f, integrator::SSPRK3, grid, dt)\n\nPerforms an update with the SSPRK3 method on grid and timestepsize dt.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.ExplicitEuler","page":"TerraDG.jl on the GPU","title":"TerraDG.ExplicitEuler","text":"ExplicitEuler(grid::Grid)\n\nReturn Euler time-integrator for grid. First order accurate.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.SSPRK2","page":"TerraDG.jl on the GPU","title":"TerraDG.SSPRK2","text":"SSPRK2(grid::Grid)\n\nReturn SSPRK2 time-integrator for grid. Two-stage strong-stability preserving Runge Kutta method. Second order accurate.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.SSPRK3","page":"TerraDG.jl on the GPU","title":"TerraDG.SSPRK3","text":"SSPRK3(grid::Grid)\n\nReturn SSPRK3 time-integrator for grid. Three-stage strong-stability preserving Runge Kutta method. Third order accurate.\n\n\n\n\n\n","category":"type"},{"location":"#Surface","page":"TerraDG.jl on the GPU","title":"Surface","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.project_to_face\nTerraDG.evaluate_face_integrals\nTerraDG.project_flux_to_face\nTerraDG.project_face_to_inner","category":"page"},{"location":"#TerraDG.project_to_face","page":"TerraDG.jl on the GPU","title":"TerraDG.project_to_face","text":"project_to_face(projection_vector_0,projection_vector_1, dofs, faceval)\n\nProjects the dofs to the face using the projection vectors and the bottom face. Uses sum factorization to avoid unnecessary allocations.\n\nThe Val argument is used to dispatch on the face at compile time.\n\n\n\n\n\nproject_to_face(projection_vector_0,projection_vector_1, dofs, faceval)\n\nProjects the dofs to the face using the projection vectors and the top face. Uses sum factorization to avoid unnecessary allocations.\n\n\n\n\n\nproject_to_face(projection_vector_0,projection_vector_1, dofs, faceval)\n\nProjects the dofs to the face using the projection vectors and the left face. Uses sum factorization to avoid unnecessary allocations.\n\n\n\n\n\nproject_to_face(projection_vector_0,projection_vector_1, dofs, faceval)\n\nProjects the dofs to the face using the projection vectors and the right face. Uses sum factorization to avoid unnecessary allocations.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.evaluate_face_integrals","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_face_integrals","text":"This version of the face integral relies on a certain order of the cells, as created in grid.jl. We iterate over all faces and compute the numerical fluxes and the updates for the cells neighboring the face. This function uses sum factorizations.\n\nFor a more simple and compatible version, see the cuda_derivative_factorization branch.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.project_flux_to_face","page":"TerraDG.jl on the GPU","title":"TerraDG.project_flux_to_face","text":"project_flux_to_face(face_projection_matrix_for_face, flux)\n\nProjects the flux to the face using the sum factorization. First splits the flux into x and y components, then projects them to the face, and finally concatenates them.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.project_face_to_inner","page":"TerraDG.jl on the GPU","title":"TerraDG.project_face_to_inner","text":"project_face_to_inner(projection_vector_0,projection_vector_1, facedofs, faceval)\n\nProjects the face dofs to the inner dofs using the projection vectors. Legacy version, using sum factorization.\n\nSame as projection_matrix' * facedofs\n\n\n\n\n\n","category":"function"},{"location":"#Volume","page":"TerraDG.jl on the GPU","title":"Volume","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.evaluate_volumes","category":"page"},{"location":"#TerraDG.evaluate_volumes","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_volumes","text":"evaluate_volumes(globals::GlobalMatrices, grid::Grid{F,T1,T2,2,ndofs,order,T3}, du::T2) where {F,T1<:AbstractArray,T2<:AbstractArray,ndofs,order,T3}\n\nEvaluates the volume integrals for the DG-scheme on the grid grid with global matrices globals and update du.\n\nUpdates du in place.\n\nPotentially runs on the GPU through a kernel.\n\n\n\n\n\n","category":"function"},{"location":"#Flux","page":"TerraDG.jl on the GPU","title":"Flux","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.evaluate_fluxes","category":"page"},{"location":"#TerraDG.evaluate_fluxes","page":"TerraDG.jl on the GPU","title":"TerraDG.evaluate_fluxes","text":"evaluate_fluxes(eq::Equation, grid::Grid, dofs)\n\nEvaluates the fluxes for the given equation eq on the grid grid with the given degrees of freedom dofs. Updates grid.flux in place. Possibly runs on a GPU.\n\n\n\n\n\n","category":"function"},{"location":"#Slope-limiting","page":"TerraDG.jl on the GPU","title":"Slope limiting","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.minmod_slope_limiting!\nTerraDG.SlopeLimitingBuffer\nTerraDG.compute_slope_limiting_coefficients!","category":"page"},{"location":"#TerraDG.minmod_slope_limiting!","page":"TerraDG.jl on the GPU","title":"TerraDG.minmod_slope_limiting!","text":"minmod_slope_limiting!(grid::Grid, buffer::SlopeLimitingBuffer)\n\nPerform slope minmod limiting on the grid grid using the cell averages and slopes stored in buffer. Potentially runs on a GPU.\n\n\n\n\n\n","category":"function"},{"location":"#TerraDG.SlopeLimitingBuffer","page":"TerraDG.jl on the GPU","title":"TerraDG.SlopeLimitingBuffer","text":"SlopeLimitingBuffer\n\nA buffer to store the cell averages and slopes for slope limiting.     All fields are potentially on GPU.\n\n\n\n\n\n","category":"type"},{"location":"#TerraDG.compute_slope_limiting_coefficients!","page":"TerraDG.jl on the GPU","title":"TerraDG.compute_slope_limiting_coefficients!","text":"compute_slope_limiting_coefficients!(grid::Grid, buffer::SlopeLimitingBuffer)\n\nCompute the cell averages and slopes for slope limiting on the grid grid and store them in buffer. Potentially runs on a GPU. Slopes and averages are estimated using Gauss quadrature.\n\n\n\n\n\n","category":"function"},{"location":"#Initial-Conditions","page":"TerraDG.jl on the GPU","title":"Initial Conditions","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"TerraDG.set_initial_conditions","category":"page"},{"location":"#TerraDG.set_initial_conditions","page":"TerraDG.jl on the GPU","title":"TerraDG.set_initial_conditions","text":"set_initial_conditions(eq::Equation, scenario::Scenario, grid::Grid)\n\nSets the initial conditions for the given equation eq and scenario scenario on the grid grid. Possibly runs on a GPU.\n\n\n\n\n\n","category":"function"},{"location":"#Index","page":"TerraDG.jl on the GPU","title":"Index","text":"","category":"section"},{"location":"","page":"TerraDG.jl on the GPU","title":"TerraDG.jl on the GPU","text":"","category":"page"}]
}
